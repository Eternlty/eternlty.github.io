import{i as N,G as A}from"./graph-CZ97irWc.js";import{m as $,l as H}from"./layout-BnX3MQGp.js";import{c as V}from"./clone-DoEUxr2i.js";import{i as U,u as W,s as _,a as q,b as z,g as D,p as O,c as K,d as Q,e as p,f as J,h as Y,j as Z}from"./edges-e0da2a9e-C2nM4eph.js";import{l as s,g as T,r as S,d as L}from"./index-BkkyqH7o.js";import{a as I}from"./createText-2e5e7dd3-DevVXwc5.js";function m(t){var e={options:{directed:t.isDirected(),multigraph:t.isMultigraph(),compound:t.isCompound()},nodes:tt(t),edges:et(t)};return N(t.graph())||(e.value=V(t.graph())),e}function tt(t){return $(t.nodes(),function(e){var n=t.node(e),r=t.parent(e),i={v:e};return N(n)||(i.value=n),N(r)||(i.parent=r),i})}function et(t){return $(t.edges(),function(e){var n=t.edge(e),r={v:e.v,w:e.w};return N(e.name)||(r.name=e.name),N(n)||(r.value=n),r})}let l={},g={},R={};const nt=()=>{g={},R={},l={}},B=(t,e)=>(s.trace("In isDescendant",e," ",t," = ",g[e].includes(t)),!!g[e].includes(t)),it=(t,e)=>(s.info("Descendants of ",e," is ",g[e]),s.info("Edge is ",t),t.v!==e&&t.w!==e&&(g[e]?g[e].includes(t.v)||B(t.v,e)||B(t.w,e)||g[e].includes(t.w):(s.debug("Tilt, ",e,",not in descendants"),!1))),P=(t,e,n,r)=>{s.warn("Copying children of ",t,"root",r,"data",e.node(t),r);const i=e.children(t)||[];t!==r&&i.push(t),s.warn("Copying (nodes) clusterId",t,"nodes",i),i.forEach(i=>{if(e.children(i).length>0)P(i,e,n,r);else{const a=e.node(i);s.info("cp ",i," to ",r," with parent ",t),n.setNode(i,a),r!==e.parent(i)&&(s.warn("Setting parent",i,e.parent(i)),n.setParent(i,e.parent(i))),t!==r&&i!==t?(s.debug("Setting parent",i,t),n.setParent(i,t)):(s.info("In copy ",t,"root",r,"data",e.node(t),r),s.debug("Not Setting parent for node=",i,"cluster!==rootId",t!==r,"node!==clusterId",i!==t));const o=e.edges(i);s.debug("Copying Edges",o),o.forEach(i=>{s.info("Edge",i);const a=e.edge(i.v,i.w,i.name);s.info("Edge data",a,r);try{it(i,r)?(s.info("Copying as ",i.v,i.w,a,i.name),n.setEdge(i.v,i.w,a,i.name),s.info("newGraph edges ",n.edges(),n.edge(n.edges()[0]))):s.info("Skipping copy of edge ",i.v,"--\x3e",i.w," rootId: ",r," clusterId:",t)}catch(t){s.error(t)}})}s.debug("Removing node",i),e.removeNode(i)})},k=(t,e)=>{const n=e.children(t);let r=[...n];for(const i of n)R[i]=t,r=[...r,...k(i,e)];return r},C=(t,e)=>{s.trace("Searching",t);const n=e.children(t);if(s.trace("Searching children of id ",t,n),n.length<1)return s.trace("This is a valid node",t),t;for(const r of n){const n=C(r,e);if(n)return s.trace("Found replacement for",t," => ",n),n}},X=t=>l[t]&&l[t].externalConnections&&l[t]?l[t].id:t,st=(t,e)=>{if(!t||e>10)s.debug("Opting out, no graph ");else{s.debug("Opting in, graph "),t.nodes().forEach(function(e){t.children(e).length>0&&(s.warn("Cluster identified",e," Replacement id in edges: ",C(e,t)),g[e]=k(e,t),l[e]={id:C(e,t),clusterData:t.node(e)})}),t.nodes().forEach(function(e){const n=t.children(e),r=t.edges();n.length>0?(s.debug("Cluster identified",e,g),r.forEach(t=>{if(t.v!==e&&t.w!==e){B(t.v,e)^B(t.w,e)&&(s.warn("Edge: ",t," leaves cluster ",e),s.warn("Descendants of XXX ",e,": ",g[e]),l[e].externalConnections=!0)}})):s.debug("Not a cluster ",e,g)});for(let e of Object.keys(l)){const n=l[e].id,r=t.parent(n);r!==e&&l[r]&&!l[r].externalConnections&&(l[e].id=r)}t.edges().forEach(function(e){const n=t.edge(e);s.warn("Edge "+e.v+" -> "+e.w+": "+JSON.stringify(e)),s.warn("Edge "+e.v+" -> "+e.w+": "+JSON.stringify(t.edge(e)));let r=e.v,i=e.w;if(s.warn("Fix XXX",l,"ids:",e.v,e.w,"Translating: ",l[e.v]," --- ",l[e.w]),l[e.v]&&l[e.w]&&l[e.v]===l[e.w]){s.warn("Fixing and trixing link to self - removing XXX",e.v,e.w,e.name),s.warn("Fixing and trixing - removing XXX",e.v,e.w,e.name),r=X(e.v),i=X(e.w),t.removeEdge(e.v,e.w,e.name);const a=e.w+"---"+e.v;t.setNode(a,{domId:a,id:a,labelStyle:"",labelText:n.label,padding:0,shape:"labelRect",style:""});const o=structuredClone(n),d=structuredClone(n);o.label="",o.arrowTypeEnd="none",d.label="",o.fromCluster=e.v,d.toCluster=e.v,t.setEdge(r,a,o,e.name+"-cyclic-special"),t.setEdge(a,i,d,e.name+"-cyclic-special")}else if(l[e.v]||l[e.w]){if(s.warn("Fixing and trixing - removing XXX",e.v,e.w,e.name),r=X(e.v),i=X(e.w),t.removeEdge(e.v,e.w,e.name),r!==e.v){const i=t.parent(r);l[i].externalConnections=!0,n.fromCluster=e.v}if(i!==e.w){const r=t.parent(i);l[r].externalConnections=!0,n.toCluster=e.w}s.warn("Fix Replacing with XXX",r,i,e.name),t.setEdge(r,i,n,e.name)}}),s.warn("Adjusted Graph",m(t)),F(t,0),s.trace(l)}},F=(t,e)=>{if(s.warn("extractor - ",e,m(t),t.children("D")),e>10)return void s.error("Bailing out");let n=t.nodes(),r=!1;for(const e of n){const n=t.children(e);r=r||n.length>0}if(r){s.debug("Nodes = ",n,e);for(const r of n)if(s.debug("Extracting node",r,l,l[r]&&!l[r].externalConnections,!t.parent(r),t.node(r),t.children("D")," Depth ",e),l[r])if(!l[r].externalConnections&&t.children(r)&&t.children(r).length>0){s.warn("Cluster without external connections, without a parent and with children",r,e);let n="TB"===t.graph().rankdir?"LR":"TB";l[r]&&l[r].clusterData&&l[r].clusterData.dir&&(n=l[r].clusterData.dir,s.warn("Fixing dir",l[r].clusterData.dir,n));const i=new A({multigraph:!0,compound:!0}).setGraph({rankdir:n,nodesep:50,ranksep:50,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}});s.warn("Old graph before copy",m(t)),P(r,t,i,r),t.setNode(r,{clusterNode:!0,id:r,clusterData:l[r].clusterData,labelText:l[r].labelText,graph:i}),s.warn("New graph after copy node: (",r,")",m(i)),s.debug("Old graph after copy",m(t))}else s.warn("Cluster ** ",r," **not meeting the criteria !externalConnections:",!l[r].externalConnections," no parent: ",!t.parent(r)," children ",t.children(r)&&t.children(r).length>0,t.children("D"),e),s.debug(l);else s.debug("Not a cluster",r,e);n=t.nodes(),s.warn("New list of nodes",n);for(const r of n){const n=t.node(r);s.warn(" Now next level",r,n),n.clusterNode&&F(n.graph,e+1)}}else s.debug("Done, no node has children",t.nodes())},G=(t,e)=>{if(0===e.length)return[];let n=Object.assign(e);return e.forEach(e=>{const r=t.children(e),i=G(t,r);n=[...n,...i]}),n},rt=t=>G(t,t.children()),at=(t,e)=>{s.info("Creating subgraph rect for ",e.id,e);const n=T(),r=t.insert("g").attr("class","cluster"+(e.class?" "+e.class:"")).attr("id",e.id),i=r.insert("rect",":first-child"),a=S(n.flowchart.htmlLabels),o=r.insert("g").attr("class","cluster-label"),d="markdown"===e.labelType?I(o,e.labelText,{style:e.labelStyle,useHtmlLabels:a}):o.node().appendChild(J(e.labelText,e.labelStyle,void 0,!0));let l=d.getBBox();if(S(n.flowchart.htmlLabels)){const t=d.children[0],e=L(d);l=t.getBoundingClientRect(),e.attr("width",l.width),e.attr("height",l.height)}const c=0*e.padding,g=c/2,h=e.width<=l.width+c?l.width+c:e.width;e.width<=l.width+c?e.diff=(l.width-e.width)/2-e.padding/2:e.diff=-e.padding/2,s.trace("Data ",e,JSON.stringify(e)),i.attr("style",e.style).attr("rx",e.rx).attr("ry",e.ry).attr("x",e.x-h/2).attr("y",e.y-e.height/2-g).attr("width",h).attr("height",e.height+c);const{subGraphTitleTopMargin:f}=D(n);a?o.attr("transform",`translate(${e.x-l.width/2}, ${e.y-e.height/2+f})`):o.attr("transform",`translate(${e.x}, ${e.y-e.height/2+f})`);const u=i.node().getBBox();return e.width=u.width,e.height=u.height,e.intersect=function(t){return p(e,t)},r},ct=(t,e)=>{const n=t.insert("g").attr("class","note-cluster").attr("id",e.id),r=n.insert("rect",":first-child"),i=0*e.padding,s=i/2;r.attr("rx",e.rx).attr("ry",e.ry).attr("x",e.x-e.width/2-s).attr("y",e.y-e.height/2-s).attr("width",e.width+i).attr("height",e.height+i).attr("fill","none");const a=r.node().getBBox();return e.width=a.width,e.height=a.height,e.intersect=function(t){return p(e,t)},n},ot=(t,e)=>{const n=T(),r=t.insert("g").attr("class",e.classes).attr("id",e.id),i=r.insert("rect",":first-child"),s=r.insert("g").attr("class","cluster-label"),a=r.append("rect"),o=s.node().appendChild(J(e.labelText,e.labelStyle,void 0,!0));let d=o.getBBox();if(S(n.flowchart.htmlLabels)){const t=o.children[0],e=L(o);d=t.getBoundingClientRect(),e.attr("width",d.width),e.attr("height",d.height)}d=o.getBBox();const l=0*e.padding,c=l/2,g=e.width<=d.width+e.padding?d.width+e.padding:e.width;e.width<=d.width+e.padding?e.diff=(d.width+0*e.padding-e.width)/2:e.diff=-e.padding/2,i.attr("class","outer").attr("x",e.x-g/2-c).attr("y",e.y-e.height/2-c).attr("width",g+l).attr("height",e.height+l),a.attr("class","inner").attr("x",e.x-g/2-c).attr("y",e.y-e.height/2-c+d.height-1).attr("width",g+l).attr("height",e.height+l-d.height-3);const{subGraphTitleTopMargin:h}=D(n);s.attr("transform",`translate(${e.x-d.width/2}, ${e.y-e.height/2-e.padding/3+(S(n.flowchart.htmlLabels)?5:3)+h})`);const f=i.node().getBBox();return e.height=f.height,e.intersect=function(t){return p(e,t)},r},lt=(t,e)=>{const n=t.insert("g").attr("class",e.classes).attr("id",e.id),r=n.insert("rect",":first-child"),i=0*e.padding,s=i/2;r.attr("class","divider").attr("x",e.x-e.width/2-s).attr("y",e.y-e.height/2).attr("width",e.width+i).attr("height",e.height+i);const a=r.node().getBBox();return e.width=a.width,e.height=a.height,e.diff=-e.padding/2,e.intersect=function(t){return p(e,t)},n},ft={rect:at,roundedWithTitle:ot,noteGroup:ct,divider:lt};let j={};const dt=(t,e)=>{s.trace("Inserting cluster");const n=e.shape||"rect";j[e.id]=ft[n](t,e)},ut=()=>{j={}},M=async(t,e,n,r,i,a)=>{s.info("Graph in recursive render: XXX",m(e),i);const o=e.graph().rankdir;s.trace("Dir in recursive render - dir:",o);const d=t.insert("g").attr("class","root");e.nodes()?s.info("Recursive render XXX",e.nodes()):s.info("No nodes found for",e),e.edges().length>0&&s.trace("Recursive edges",e.edge(e.edges()[0]));const c=d.insert("g").attr("class","clusters"),g=d.insert("g").attr("class","edgePaths"),h=d.insert("g").attr("class","edgeLabels"),f=d.insert("g").attr("class","nodes");await Promise.all(e.nodes().map(async function(t){const d=e.node(t);if(void 0!==i){const n=JSON.parse(JSON.stringify(i.clusterData));s.info("Setting data for cluster XXX (",t,") ",n,i),e.setNode(i.id,n),e.parent(t)||(s.trace("Setting parent",t,i.id),e.setParent(t,i.id,n))}if(s.info("(Insert) Node XXX"+t+": "+JSON.stringify(e.node(t))),d&&d.clusterNode){s.info("Cluster identified",t,d.width,e.node(t));const i=await M(f,d.graph,n,r,e.node(t),a),o=i.elem;W(d,o),d.diff=i.diff||0,s.info("Node bounds (abc123)",t,d,d.width,d.x,d.y),_(o,d),s.warn("Recursive render complete ",o,d)}else e.children(t).length>0?(s.info("Cluster - the non recursive path XXX",t,d.id,d,e),s.info(C(d.id,e)),l[d.id]={id:C(d.id,e),node:d}):(s.info("Node - the non recursive path",t,d.id,d),await q(f,e.node(t),o))})),e.edges().forEach(function(t){const n=e.edge(t.v,t.w,t.name);s.info("Edge "+t.v+" -> "+t.w+": "+JSON.stringify(t)),s.info("Edge "+t.v+" -> "+t.w+": ",t," ",JSON.stringify(e.edge(t))),s.info("Fix",l,"ids:",t.v,t.w,"Translating: ",l[t.v],l[t.w]),z(h,n)}),e.edges().forEach(function(t){s.info("Edge "+t.v+" -> "+t.w+": "+JSON.stringify(t))}),s.info("#############################################"),s.info("###                Layout                 ###"),s.info("#############################################"),s.info(e),H(e),s.info("Graph after layout:",m(e));let u=0;const{subGraphTitleTotalMargin:p}=D(a);return rt(e).forEach(function(t){const n=e.node(t);s.info("Position "+t+": "+JSON.stringify(e.node(t))),s.info("Position "+t+": ("+n.x,","+n.y,") width: ",n.width," height: ",n.height),n&&n.clusterNode?(n.y+=p,O(n)):e.children(t).length>0?(n.height+=p,dt(c,n),l[n.id].node=n):(n.y+=p/2,O(n))}),e.edges().forEach(function(t){const i=e.edge(t);s.info("Edge "+t.v+" -> "+t.w+": "+JSON.stringify(i),i),i.points.forEach(t=>t.y+=p/2);const a=K(g,t,i,l,n,e,r);Q(i,a)}),e.nodes().forEach(function(t){const n=e.node(t);s.info(t,n.type,n.diff),"group"===n.type&&(u=n.diff)}),{elem:d,diff:u}},bt=async(t,e,n,r,i)=>{U(t,n,r,i),Y(),Z(),ut(),nt(),s.warn("Graph at first:",JSON.stringify(m(e))),st(e),s.warn("Graph after:",JSON.stringify(m(e)));const a=T();await M(t,e,r,i,void 0,a)};export{bt as r};